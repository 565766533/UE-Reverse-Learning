# UE 游戏逆向学习大纲

一个可以直接照着执行的带节奏学习路线，帮助你把仓库里的 8 个模块串成一套体系化的学习方案。建议在学习过程中配合 `docs/ProgressTracker.md` 勾选任务，形成闭环。

## 如何使用

- **按阶段推进**：每个阶段的输出都会直接为下一个阶段做准备，不要跳跃式学习。
- **理论 + 实践**：先阅读对应模块代码中的注释，再完成本大纲里的练习任务。
- **记录偏移与结论**：把每次练习得出的偏移、Hook 地址、调试心得写入自己的笔记，后续模块会复用。
- **阶段自评**：完成阶段检查点前，不要进入下一阶段；如果遇到阻塞，可回到前序阶段复盘。
- **基础 / 进阶对照**：若在某阶段感觉知识断层，可随时翻查 `docs/Foundation.md`（基础）或 `docs/Advanced.md`（进阶）快速补课。
- **单机练习**：当你准备把示例迁移到真实 UE 单机游戏时，按 `docs/SinglePlayerPractice.md` 的流程执行，保证环境可回滚且不影响在线公平性。

## 学习阶段概览

| 阶段 | 覆盖模块 | 核心成果 | 推荐时长 |
| ---- | -------- | -------- | -------- |
| 阶段 0 | 环境预备 | 完成工具安装、阅读参考资料、建立笔记体系 | 3~5 天 |
| 阶段 1 | 01 基础内存 | 能在模拟环境中定位/修改结构体成员，理解指针链 | 1~2 周 |
| 阶段 2 | 02 对象系统 + 03 工具库 | 能解析 UE 核心数据结构，编写可复用的内存操作工具 | 2~3 周 |
| 阶段 3 | 04 CE + 05 x64dbg | 熟练使用 CE 与调试器定位偏移、下断点、分析调用栈 | 2~3 周 |
| 阶段 4 | 06 Hook 技术 | 掌握 VTable Hook、函数 Hook 的选型与实现 | 1~2 周 |
| 阶段 5 | 07 ESP 项目 + 08 综合项目 | 完成一套包含 UI、配置、Hook 的完整辅助 | 3~4 周 |

## 模块路线图

| 模块 | 对应阶段 | 关键主题 | 推荐产出 | 依赖 |
| ---- | -------- | -------- | -------- | ---- |
| `01-BasicMemory/main.cpp` | 阶段 1 | 指针、偏移、模式扫描 | 书写一份常见指针链示意图 + 练习脚本 | C/C++ 基础 |
| `02-UEObjectSystem/UETypes.h` | 阶段 2 | UE 名称系统、容器、类层级 | 绘制 UObject → UWorld → Pawn 访问链图 | 模块 01 |
| `03-ReverseTools/ReverseTools.h` | 阶段 2 | 进程/模块定位、内存读写 | 封装用于后续项目的 `ProcessHelper` 工具 | 模块 01 |
| `04-CheatEngine/CEPractice.cpp` | 阶段 3 | 数值搜索、指针扫描、代码注入 | 完成 6 个 CE 任务的实验记录 | 模块 01 + 03 |
| `05-x64dbg/DebuggingGuide.cpp` | 阶段 3 | 断点、寄存器、调用栈分析 | 输出 6 个调试场景的实验日志 | 模块 03 |
| `06-HookingTechniques/VTableHook.cpp` | 阶段 4 | VTable Hook、对象模拟、反检测思路 | Hook 技术对比表 + Demo 截图 | 模块 02 + 03 |
| `07-RealWorldProject/ESPProject.cpp` | 阶段 5 | ESP 渲染、对象过滤、偏移追踪 | 运行 Demo，记录数据收集流程 | 模块 04~06 |
| `08-FinalProject/ComprehensiveCheat.cpp` | 阶段 5 | 菜单系统、配置、热键、功能整合 | 输出最终项目复盘报告 | 所有前序 |

> 小贴士：每次完成模块后，把你的实验记录保存在 `notes/` 或个人笔记软件里，便于在综合项目阶段快速查阅。

## 阶段 0 ─ 预备工作

**目标**：搭建环境、明确知识短板、建立资料库。

- [ ] 搭建 Windows 调试环境（实体机或虚拟机），安装 Visual Studio、Cheat Engine、x64dbg、IDA Free/Ghidra。
- [ ] 阅读推荐资料：C++ 指针与引用复习、Windows 内存模型、基本汇编指令。
- [ ] 建立知识笔记模板：包含“概念 → 实验 → 总结”三段结构。
- [ ] 熟悉仓库结构，确认能编译/运行一个示例（建议从 `01-BasicMemory` 开始）。

阶段 0 自检：

- [ ] 说得清“虚拟地址空间”、“模块基址”、“多级指针”的含义。
- [ ] 能独立安装并启动 CE/x64dbg，并创建最小工程（Hello World）。
- [ ] 准备好未来记录偏移/结构的笔记模版或 ReClass 图。

---

## 模块 01 ─ 内存操作基础（`01-BasicMemory/main.cpp`）

**学习目标**
- 通过结构体理解游戏数据在内存中的布局。
- 学会使用偏移和多级指针定位数据。
- 对 Pattern Scan（特征码扫描）有直观认识。

**理论拆解**
- 结构体内存布局与对齐，`offsetof` 的含义。
- 指针、多级指针在 UE 中的典型链路。
- 静态数组 vs. 动态数组的内存连续性。

**实践任务**
1. 改写 `Demo_DirectAccess`，新增一个 `armor` 字段并通过指针修改，记录偏移。
2. 在 `Demo_PointerOffset` 中打印结构体的字节布局，确认实际偏移是否与推测一致。
3. 基于 `Demo_PatternScan`，设计一段包含通配符 `??` 的特征码，并写出对应匹配逻辑伪代码。
4. 结合 CE，在真实进程中尝试寻找一个整型数值并验证偏移与 Demo 的关系。

**自检清单**
- [ ] 能解释为什么多级指针会随更新改变，并指出如何更新链路。
- [ ] 能手写一个简单的 Pattern Scan 循环（无须 SSE 优化）。
- [ ] 知道在 64 位进程里指针与偏移的字节数差异。

---

## 模块 02 ─ UE 对象系统（`02-UEObjectSystem/UETypes.h`）

**学习目标**
- 掌握 UE 中常见的数据结构：`FName`、`TArray`、`UObject`层级。
- 理解 GName / GObject 全局表在逆向中的作用。
- 能够根据类继承关系推断对象内存布局。

**实践任务**
1. 绘制 `UWorld → GameInstance → LocalPlayers → PlayerController → Pawn → Character` 的访问链，并标注每一步的结构体类型及偏移字段。
2. 在 `TArray` 模拟实现中加入边界检查日志，观察 `Count` 和 `Max` 在插入/删除时的变化（可编写额外的测试函数）。
3. 设计一个“对象过滤”伪代码：遍历 `TArray<AActor*>`，筛选出 `Health < 50` 的角色并输出 `FName`。
4. 结合 IDA/Ghidra，尝试在任意 UE 游戏样本中定位 `GWorld`、`GNames` 的特征模式，记录分析步骤。

**自检清单**
- [ ] 能解释 FName 为什么用索引；知道如何从索引 -> 字符串。
- [ ] 明确 UObject 内常见成员（`VTable`、`Class`、`Name`、`Outer`）的顺序与含义。
- [ ] 理解 Actor 继承体系与组件（Component）的关系。

---

## 模块 03 ─ 实战工具库（`03-ReverseTools/ReverseTools.h`）

**学习目标**
- 能够枚举进程、模块、导出函数，获取基址与偏移。
- 编写稳定的内存读写函数，处理失败与错误码。
- 实践 Pattern Scan、指针链解析等常用逆向工具逻辑。

**实践任务**
1. 用仓库中的 `ProcessHelper`/`MemoryReader` 模板，封装一个 CLI 小工具，输入进程名返回模块基址（可放在 `tools/` 目录）。
2. 编写一个“特征码扫描”实用函数，支持 `??` 和 `?F` 这种半字节通配符，并在模拟内存中测试。
3. 为读写内存函数添加错误处理：例如进程句柄无效、读写失败时打印 `GetLastError()`。
4. 与模块 02 联动：通过 Pattern Scan 定位 `GNames` 地址，并验证读取出的字符串正确性（可在单元测试或简单 main 中打印）。

**自检清单**
- [ ] 清楚 `OpenProcess`/`ReadProcessMemory`/`WriteProcessMemory` 的常见返回错误。
- [ ] 知道如何获取某个模块内存区间、遍历内存页。
- [ ] 理解工具库在后续项目中的调用方式，确保接口稳定。

---

## 模块 04 ─ Cheat Engine 实战（`04-CheatEngine/CEPractice.cpp`）

**学习目标**
- 熟悉 CE 的数值搜索、指针扫描和代码注入流程。
- 通过 6 个练习任务理解静态地址、动态地址与指针链更新。
- 学会在 CE 中记录和复用偏移信息。

**实践任务**
1. 依次完成示例中的 6 个任务，并在笔记中记录搜索策略、过滤条件、最终偏移。
2. 利用模块 03 的工具对照验证 CE 找出的指针链是否正确。
3. 将一个 CE 指针表导出为 `*.CT`，并在笔记里总结地址在游戏更新后如何重新定位。
4. 尝试使用 CE 的 Auto Assembler 对模拟游戏注入一段修改血量的代码，记录汇编指令与恢复流程。

**自检清单**
- [ ] 能解释“首次扫描”和“再次扫描”的筛选逻辑。
- [ ] 会使用指针扫描结果定位链路，并理解偏移更新策略。
- [ ] 熟悉 Auto Assembler 脚本的基本结构。

---

## 模块 05 ─ x64dbg 动态调试（`05-x64dbg/DebuggingGuide.cpp`）

**学习目标**
- 掌握断点、内存监视、寄存器追踪等常用调试技巧。
- 能够分析调用栈，反推出函数参数与返回值。
- 熟悉条件断点、日志断点等进阶用法。

**实践任务**
1. 为 6 个调试场景分别制作调试记录：包含断点位置、关键寄存器、堆栈截图。
2. 尝试设置“命中一次就停”的条件断点，定位某血量写入函数。
3. 利用调用栈分析，恢复一个函数的伪代码并在笔记中总结参数含义。
4. 结合 CE，将调试到的写入地址制作成 Auto Assembler 脚本，验证两者能互相印证。

**自检清单**
- [ ] 能说清 x64dbg 的 `RIP`、`RSP`、`RBP` 的作用。
- [ ] 熟悉 `Log`、`Trace` 功能的使用场景。
- [ ] 知道如何导出调用栈信息以供后续分析。

---

## 模块 06 ─ Hook 技术（`06-HookingTechniques/VTableHook.cpp`）

**学习目标**
- 理解 VTable 布局及其在 UE 对象中的位置。
- 学会编写 VTable Hook、虚函数替换、函数指针保存等关键步骤。
- 了解常见反作弊检测点，初步掌握规避思路。

**实践任务**
1. 在 Demo 中新增一个虚函数 Hook，输出被 Hook 对象的 `FName`，确认调用次数与调用时机。
2. 分析示例代码中的多种 Hook 方式，整理优缺点（例如 Detour、VTable 替换、Inline Hook），完成一份对比表。
3. 结合模块 05 的调试技巧，手动定位一个可 Hook 的虚函数地址，并验证替换是否成功。
4. 思考反检测策略：列出至少 3 种常见检测点，并写下对应的规避方案或思路。

**自检清单**
- [ ] 清楚调用约定（`__stdcall`、`__fastcall` 等）对 Hook 的影响。
- [ ] 能解释为什么要保存原函数指针，以及如何恢复。
- [ ] 了解 VTable Hook 与 Inline Hook 在检测层面的差异。

---

## 模块 07 ─ ESP 实战（`07-RealWorldProject/ESPProject.cpp` & `SimulatedGame.h`）

**学习目标**
- 在模拟 UE 环境中实现完整的数据采集 → 处理 → 渲染流程。
- 熟悉 Actor 遍历、骨骼/坐标转换、视野过滤等步骤。
- 练习如何追踪版本更新导致的偏移变化。

**实践任务**
1. 运行 ESP Demo，确认能在控制台/简单 GUI 中看到玩家列表和坐标。
2. 结合模块 02 的结构体，手动追踪 `PlayerController → Pawn → Mesh → Bones` 的偏移，画出数据流图。
3. 在 Demo 中新增一个“距离过滤”或“友军过滤”功能，并记录需要新增的偏移/字段。
4. 制作一份“偏移更新手册”：当游戏版本更新时，如何定位关键结构并更新到代码中。

**自检清单**
- [ ] 知道世界坐标转换为屏幕坐标的公式（Project World To Screen）。
- [ ] 清楚 ESP 渲染中常见的性能瓶颈和优化手段。
- [ ] 熟悉对象缓存、可见性检测等进阶议题的基本思路。

---

## 模块 08 ─ 综合项目（`08-FinalProject/ComprehensiveCheat.cpp`）

**学习目标**
- 将菜单、配置、热键、功能逻辑整合成可维护的项目。
- 落实日志系统、异常捕获、功能开关等工程化细节。
- 完成一次完整的需求 → 设计 → 实现 → 复盘流程。

**实践任务**
1. 运行综合项目，读懂菜单层级与功能模块的组织方式（ESP、Aimbot、辅助功能等）。
2. 设计一个“最小可行修改”：例如新增一个“骨骼透视”开关或“自动拾取”逻辑，并实现之。
3. 将模块 03 的工具封装为独立类，在综合项目中调用，验证代码复用性。
4. 撰写最终复盘报告：包含需求分析、实现要点、遇到的问题、下一步计划。

**自检清单**
- [ ] 能解释项目中为何要有配置/日志/热键系统。
- [ ] 知道如何把多线程或定时器引入到辅助项目中。
- [ ] 对可能的反作弊检测点有应对策略（如模块隐藏、驱动层实现等）。

---

## 阶段性检查点

| 检查点 | 触发条件 | 需要输出 |
| ------ | -------- | -------- |
| 基础达成 | 完成模块 01~03 自检清单 | `ProcessHelper` 小工具、对象结构图、Pattern Scan 伪代码 |
| 工具熟练 | 完成模块 04~05 实践任务 | CE 练习记录、x64dbg 调试日志、指针链对比文档 |
| Hook 掌握 | 完成模块 06 自检清单 | Hook 对比表、反检测思路文档 |
| 项目成型 | 完成模块 07~08 实践任务 | ESP 功能截图、最终复盘报告、配套工具代码 |

建议在每个检查点前回顾自己的笔记，确保“能讲出来、能写出来、能做出来”。

## 长期进阶建议

- 每月挑选一个真实 UE 游戏做偏移更新演练，保持敏感度。
- 阅读 Unreal Engine 源码或社区 SDK，验证自己推测的结构是否准确。
- 关注安全社区（GuidedHacking、UnknownCheats），学习最新反检测与驱动层技术。
- 规划进一步的专题：如物理引擎逆向、反作弊对抗、驱动编写等。

保持输出、持续复盘，就能把“看得懂 Demo”升级成“能独立完成项目”。祝学习顺利！
